---
title: "leetcode_1225: Report Contiguous Dates"
date: 2025-06-10
categories: [sql_coding]
tags: []
toc: true
toc_label: "Table of contents"
toc_icon: "cog"
---

## 문제 

Table: Failed

| Column Name  | Type    |
|--------------|---------|
| fail_date    | date    |

fail_date is the primary key (column with unique values) for this table.
This table contains the days of failed tasks.

Table: Succeeded

| Column Name  | Type    |
|--------------|---------|
| success_date | date    |

success_date is the primary key (column with unique values) for this table.
This table contains the days of succeeded tasks.

A system is running one task every day. Every task is independent of the previous tasks. The tasks can fail or succeed.

Write a solution to report the period_state for each continuous interval of days in the period from 2019-01-01 to 2019-12-31.

period_state is 'failed' if tasks in this interval failed or 'succeeded' if tasks in this interval succeeded. Interval of days are retrieved as start_date and end_date.

Return the result table ordered by start_date.

## 내 시도 

~~~sql
# Write your MySQL query statement below
WITH fail_cte AS(
SELECT  fail_date
        ,RANK() OVER (ORDER BY fail_date) as rk
  FROM  Failed
 WHERE  EXTRACT(YEAR FROM fail_date) = 2019
)
WITH consecutive AS
(SELECT  a.fail_date AS cur_fail
        ,b.fail_date AS nxt_fail
        ,DATEDIFF(b.fail_date,a.fail_date) AS consecutive
        ,CASE WHEN 
  FROM  fail_cte a
  JOIN  fail_cte b
    ON  a.rk = b.rk - 1
)
WITH RECURSIVE failed AS
(
    SELECT  cur_fail
            ,nxt_fail 
      FROM  consecutive
     WHERE  cur_fail - 1 NOT IN (SELECT cur_fail FROM consecutive)
     UNION  
     SELECT a.cur_fail
            ,b.nxt_fail
       FROM failed a
       JOIN consecutive b
         ON a.nxt_fail = b.cur_fail
)
~~~

## 답안

~~~sql
WITH all_days AS (
  -- 2019년 범위 내에 실패/성공 날짜를 하나의 테이블로 합치기
  SELECT
    fail_date AS dt,
    'failed'    AS period_state
  FROM Failed
  WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31'
  UNION ALL
  SELECT
    success_date AS dt,
    'succeeded'   AS period_state
  FROM Succeeded
  WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31'
),
flagged AS (
  SELECT
    dt,
    period_state,
    -- 이전 날짜가 없거나, 하루 이상 차이가 나거나, 상태가 바뀌면 새 구간 시작
    CASE
      WHEN LAG(dt) OVER (ORDER BY dt) IS NULL
        OR DATEDIFF(dt, LAG(dt) OVER (ORDER BY dt)) > 1
        OR period_state <> LAG(period_state) OVER (ORDER BY dt)
      THEN 1 ELSE 0
    END AS is_new_group
  FROM all_days
),
grp AS (
  SELECT
    dt,
    period_state,
    -- 누적 합으로 그룹 번호 할당
    SUM(is_new_group) OVER (ORDER BY dt) AS grp
  FROM flagged
)
SELECT
  period_state,
  MIN(dt) AS start_date,
  MAX(dt) AS end_date
FROM grp
GROUP BY grp, period_state
ORDER BY start_date;
~~~
